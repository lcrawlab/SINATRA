compute_discrete_ec_curve(complex, vertex_function, curve_length-1, first_column_index = TRUE)
source('R/Critical_Points_and_plot.R')
source('R/GP_Generation.R')
source('R/SECT_final.R')
source('R/Tests and Simple Examples/GaussiansOnPlaneExample/Generate_fields.R')
source('R/SECT.R')
source('R/SECT_Functions.R')
source('R/Tests and Simple Examples/GaussiansOnPlaneExample/Generate_fields.R')
library(plot3D)
library(Rcpp)
library(RcppArmadillo)
library(kernlab)
library(doParallel)
sourceCpp("R/BAKRGibbs.cpp")
source('R/RATE_Code/RATEv2.R')
source('R/RATE.R')
library(varbvs)
# specify the critical points for the flat plane with gaussians example.
points_1 = matrix(c(0.25,0.25,random_field_class_one(c(0.25,0.25)),
0.75,0.75,random_field_class_one(c(0.75,0.75)),
0.5,0.5,random_field_class_one(c(0.5,0.5)),
0.2,0.9,random_field_class_one(c(0.2,0.9))),nrow = 4, byrow = TRUE)
points_2 = matrix(c(0.25,0.25,random_field_class_two(c(0.25,0.25)),
0.75,0.75,random_field_class_two(c(0.75,0.75)),
0.5,0.5,random_field_class_two(c(0.5,0.5)),
0.8,0.1,random_field_class_two(c(0.8,0.1))),nrow = 4, byrow = TRUE)
#generate the desired directions
#directions = generate_equidistributed_points_hemisphere(25)
directions = matrix(c(0,0,1,
1/sqrt(3),1/sqrt(3),1/sqrt(3),
-1/sqrt(3),1/sqrt(3),1/sqrt(3),
1/sqrt(3),-1/sqrt(3),1/sqrt(3),
-1/sqrt(3),-1/sqrt(3),1/sqrt(3)),
ncol = 3, byrow = TRUE)
directions <- rbind(directions,-directions)
grid_length = 40
num_sim = 50
data = create_data_gaussian(num_sim = 50,grid_size = grid_length, dir = directions)
source('~/Desktop/projects/SINATRA/R/Simulation_Functions.R')
# how about start with flat plane with added normal densities add several points
### Generating Two Classes of GPs ###
# specify the training points that are to be fixed.
noncausal_points = matrix(c(0,0,-0.5,
0.1,0.1,0.5,
0.2,0.2,-0.5,
0.3,0.3,0.5,
0.4,0.4,-0.5,
0.5,0.5,0.5,
0.6,0.6,-0.5,
0.7,0.7,0.5,
0.8,0.8,-0.5), nrow = 9, byrow = TRUE)
#specify the class specific points.
class_one_causal_points = matrix(c(0.75,0.25,-0.5,
0.95,0.1,0.5,
0.6,0.4,-0.5),nrow = 3, byrow = TRUE)
class_two_causal_points = matrix(c(0.25,0.75,-0.5,
0.1,0.95,0.5,
0.4,0.6,-0.5),nrow = 3, byrow = TRUE)
class_one_points = rbind(noncausal_points, class_one_causal_points) # recenter the points
class_two_points = rbind(noncausal_points, class_two_causal_points)
#generate the desired directions
#directions = generate_equidistributed_points_hemisphere(25)
directions = matrix(c(0,0,1, 1/sqrt(2),0,1/sqrt(2), 0,1/sqrt(2),1/sqrt(2)), ncol = 3, byrow = TRUE)
grid_length = 50
data = create_data_gp(num_sim = 50,grid_size = grid_length, dir = directions)
source('R/Critical_Points_and_plot.R')
source('R/GP_Generation.R')
source('R/Tests and Simple Examples/GaussiansOnPlaneExample/Generate_fields.R')
# how about start with flat plane with added normal densities add several points
### Generating Two Classes of GPs ###
# specify the training points that are to be fixed.
noncausal_points = matrix(c(0,0,-0.5,
0.1,0.1,0.5,
0.2,0.2,-0.5,
0.3,0.3,0.5,
0.4,0.4,-0.5,
0.5,0.5,0.5,
0.6,0.6,-0.5,
0.7,0.7,0.5,
0.8,0.8,-0.5), nrow = 9, byrow = TRUE)
#specify the class specific points.
class_one_causal_points = matrix(c(0.75,0.25,-0.5,
0.95,0.1,0.5,
0.6,0.4,-0.5),nrow = 3, byrow = TRUE)
class_two_causal_points = matrix(c(0.25,0.75,-0.5,
0.1,0.95,0.5,
0.4,0.6,-0.5),nrow = 3, byrow = TRUE)
class_one_points = rbind(noncausal_points, class_one_causal_points) # recenter the points
class_two_points = rbind(noncausal_points, class_two_causal_points)
#generate the desired directions
#directions = generate_equidistributed_points_hemisphere(25)
directions = matrix(c(0,0,1, 1/sqrt(2),0,1/sqrt(2), 0,1/sqrt(2),1/sqrt(2)), ncol = 3, byrow = TRUE)
grid_length = 50
data = create_data_gp(num_sim = 50,grid_size = grid_length, dir = directions)
View(create_data_gp)
posterior_matrix1=generate_gp(grid_length,class_one_points,length_scale = 5)
posterior_matrix1=generate_gp(grid_length,class_one_points,length_scale = 5)
data = create_data_gaussian(num_sim = 50,grid_size = grid_length, dir = directions)
grf_mesh_posterior1 = visualize_random_field('GP_1')
source('R/Critical_Points_and_plot.R')
setwd("~/Dropbox/Data + Experiments/Topological_Reconstruction/GaussiansOnPlaneExample")
setwd('../')
source('../Final Code for Functions (Really)/Critical_Points_and_plot.R')
source('../Final Code for Functions (Really)/GP_Generation.R')
source('../Final Code for Functions (Really)/SECT_final.R')
source('Generate_fields.R')
source('/GaussiansOnPlaneExample/Generate_fields.R')
source('GaussiansOnPlaneExample/Generate_fields.R')
library(plot3D)
library(Rcpp)
library(RcppArmadillo)
library(kernlab)
library(doParallel)
sourceCpp("../RATE_Code/BAKRGibbs.cpp")
sourceCpp("../RATE_Code/BAKRGibbs.cpp")
source('../RATE_Code/RATEv2.R')
library(varbvs)
# specify the critical points for the flat plane with gaussians example.
points_1 = matrix(c(0.25,0.25,random_field_class_one(c(0.25,0.25)),
0.75,0.75,random_field_class_one(c(0.75,0.75)),
0.5,0.5,random_field_class_one(c(0.5,0.5)),
0.2,0.9,random_field_class_one(c(0.2,0.9))),nrow = 4, byrow = TRUE)
points_2 = matrix(c(0.25,0.25,random_field_class_two(c(0.25,0.25)),
0.75,0.75,random_field_class_two(c(0.75,0.75)),
0.5,0.5,random_field_class_two(c(0.5,0.5)),
0.8,0.1,random_field_class_two(c(0.8,0.1))),nrow = 4, byrow = TRUE)
#generate the desired directions
#directions = generate_equidistributed_points_hemisphere(25)
directions = matrix(c(0,0,1,
1/sqrt(3),1/sqrt(3),1/sqrt(3),
-1/sqrt(3),1/sqrt(3),1/sqrt(3),
1/sqrt(3),-1/sqrt(3),1/sqrt(3),
-1/sqrt(3),-1/sqrt(3),1/sqrt(3)),
ncol = 3, byrow = TRUE)
directions <- rbind(directions,-directions)
grid_length = 40
data = create_data_gaussian(num_sim = 30,grid_size = grid_length, dir = directions)
source('GaussiansOnPlaneExample/Generate_fields.R')
grf_mesh_posterior1 = visualize_random_field('GP_1')
# Visualizes the random field in an OFF file, and outputs the computed mesh.
visualize_random_field <- function(filename){
posterior_matrix1=generate_matrix_class_one(grid_length)
posterior_complex1 <- MatrixtoSimplicialComplexTriangular(posterior_matrix1,grid_length)
posterior_complex1$Vertices[,2]=posterior_complex1$Vertices[,2]/(grid_length/2)
posterior_complex1$Vertices[,3]=posterior_complex1$Vertices[,3]/(grid_length/2)
try_vertex1=posterior_complex1$Vertices[,2:3]
try_faces1=posterior_complex1$Faces
ind1 = rep(1,dim(try_vertex1)[1])
try_vertex1 = cbind(try_vertex1,ind1)
grf_mesh_posterior1=tmesh3d(t(try_vertex1),indices=t(try_faces1))
plot3d(grf_mesh_posterior1,col = alpha.col('grey',alpha=0.1))
aspect3d(1,1,1)
#Write to one OFF file
vcgOffWrite(grf_mesh_posterior1,filename=filename)
grf_mesh_posterior1
}
grf_mesh_posterior1 = visualize_random_field('GP_1')
posterior_matrix1=generate_matrix_class_one(grid_length)
posterior_complex1 <- MatrixtoSimplicialComplexTriangular(posterior_matrix1,grid_length)
posterior_complex1$Vertices[,2]=posterior_complex1$Vertices[,2]/(grid_length/2)
posterior_complex1$Vertices[,3]=posterior_complex1$Vertices[,3]/(grid_length/2)
try_vertex1=posterior_complex1$Vertices[,2:3]
try_vertex1=posterior_complex1$Vertices[,1:2]
try_faces1=posterior_complex1$Faces
ind1 = rep(1,dim(try_vertex1)[1])
try_vertex1 = cbind(try_vertex1,ind1)
grf_mesh_posterior1=tmesh3d(t(try_vertex1),indices=t(try_faces1))
plot3d(grf_mesh_posterior1)
posterior_complex1
try_vertex1=posterior_complex1$Vertices[,1:3]
try_faces1=posterior_complex1$Faces
ind1 = rep(1,dim(try_vertex1)[1])
try_vertex1 = cbind(try_vertex1,ind1)
grf_mesh_posterior1=tmesh3d(t(try_vertex1),indices=t(try_faces1))
plot3d(grf_mesh_posterior1)
aspect3d(1,1,1)
# Visualizes the random field in an OFF file, and outputs the computed mesh.
visualize_random_field <- function(filename){
posterior_matrix1=generate_matrix_class_one(grid_length)
posterior_complex1 <- MatrixtoSimplicialComplexTriangular(posterior_matrix1,grid_length)
try_vertex1=posterior_complex1$Vertices[,1:3]
try_faces1=posterior_complex1$Faces
ind1 = rep(1,dim(try_vertex1)[1])
try_vertex1 = cbind(try_vertex1,ind1)
grf_mesh_posterior1=tmesh3d(t(try_vertex1),indices=t(try_faces1))
plot3d(grf_mesh_posterior1,col = alpha.col('grey',alpha=0.1))
aspect3d(1,1,1)
#Write to one OFF file
vcgOffWrite(grf_mesh_posterior1,filename=filename)
grf_mesh_posterior1
}
grf_mesh_posterior1 = visualize_random_field('GP_1')
grf_mesh_posterior1 = visualize_random_field('GP_1',1)
# Visualizes the random field in an OFF file, and outputs the computed mesh.
visualize_random_field <- function(filename,type){
#specify the class
if(type == 1){
posterior_matrix1=generate_matrix_class_one(grid_length)
}else{
posterior_matrix1=generate_matrix_class_two(grid_length)
}
posterior_complex1 <- MatrixtoSimplicialComplexTriangular(posterior_matrix1,grid_length)
try_vertex1=posterior_complex1$Vertices[,1:3]
try_faces1=posterior_complex1$Faces
ind1 = rep(1,dim(try_vertex1)[1])
try_vertex1 = cbind(try_vertex1,ind1)
grf_mesh_posterior1=tmesh3d(t(try_vertex1),indices=t(try_faces1))
plot3d(grf_mesh_posterior1,col = alpha.col('grey',alpha=0.1))
aspect3d(1,1,1)
#Write to one OFF file
vcgOffWrite(grf_mesh_posterior1,filename=filename)
grf_mesh_posterior1
}
grf_mesh_posterior1 = visualize_random_field('GP_1',1)
grf_mesh_posterior2 = visualize_random_field('GP_2',2)
### Feature Selection and Reconstruction ###
# We use Rate. Fit a Gaussian process classifier to this data
ind <- sample(1:dim(data)[1],30)
gpc(data,ind)
source('../Final Code for Functions (Really)/Feature_Selection.R')
#### Other Functions ####
# Gaussian Process Classification - data is assumed to have classes 1,-1 on the first column
gpc = function(gp_data,test_indices){
ind=test_indices
gp_data[,1]=ifelse(gp_data[,1]>0,1,-1)
train_data <- gp_data[-ind,-1]
train_labels <- gp_data[-ind,1]
test_data <- gp_data[ind,-1]
test_labels <- gp_data[ind,1]
# fit the GP
gp <- gausspr(x = train_data,y = train_labels, kernel = 'rbfdot', kpar = list(sigma = 0.015))
label_probabilities <- predict(gp, test_data, type = 'probabilities')
predicted_labels <- ifelse(label_probabilities > 0, 1,-1)
# get the results of classification
#cm = table(predicted_labels, test_labels)
#correct = (cm[1,1] + cm[2,2])/sum(cm)
#correct
correct=sum(predicted_labels==test_labels)/length(test_labels)
correct
}
### Need to implement stratified
kfoldcvgp = function(k = 10,data){
if ((dim(data)[1]%%k) != 0){
k=k-1
return(kfoldcvgp(k=k,data))
}
cv.errors = rep(0,k)
indices = sample(1:dim(data)[1])
inc = dim(data)[1]/k
for (i in 1:k){
cv.errors[i] = gpc(data,indices[((i-1)*inc+1):(i*inc)])
}
c(mean(cv.errors),std(cv.errors))
}
#### For accuracy with multiple methods ####
test_accuracy = function(gp_data,test_indices){
ind=test_indices
train_data <- gp_data[-ind,-1]
train_labels <- gp_data[-ind,1]
train_labels_gpc=ifelse(train_labels>0,1,-1)
test_data <- gp_data[ind,-1]
test_labels <- gp_data[ind,1]
test_labels_gpc=ifelse(test_labels>0,1,-1)
# fit the GP
gp <- gausspr(x = train_data,y = train_labels_gpc, kernel = 'rbfdot', kpar = list(sigma = 0.015))
lasso=cv.glmnet(train_data, train_labels, alpha = 0.95,intercept = FALSE,family='binomial')
bayesian=varbvs(X = train_data,Z = NULL, y= train_labels,family='binomial',verbose = FALSE)
elastic=cv.glmnet(train_data, train_labels, alpha = 0.5,intercept = FALSE,family='binomial')
label_probabilities_gp <- predict(gp, test_data, type = 'probabilities')
label_probabilities_lasso <- predict(lasso, test_data)
label_probabilities_bayesian <- predict(bayesian, test_data)
label_probabilities_elastic= predict(elastic, test_data)
predicted_labels_gp <- ifelse(label_probabilities_gp > 0, 1,-1)
predicted_labels_lasso <- ifelse(label_probabilities_lasso > 0, 1,0)
predicted_labels_bayesian <- ifelse(label_probabilities_bayesian > 0, 1,0)
predicted_labels_elastic <- ifelse(label_probabilities_elastic > 0, 1,0)
# get the results of classification
#cm = table(predicted_labels, test_labels)
#correct = (cm[1,1] + cm[2,2])/sum(cm)
correct_gp=sum(predicted_labels_gp==test_labels_gpc)/length(test_labels)
correct_lasso=sum(predicted_labels_lasso==test_labels)/length(test_labels)
correct_bayesian=sum(predicted_labels_bayesian==test_labels)/length(test_labels)
correct_elastic=sum(predicted_labels_elastic==test_labels)/length(test_labels)
return(c(correct_gp,correct_lasso,correct_bayesian,correct_elastic))
}
### Feature Selection and Reconstruction ###
# We use Rate. Fit a Gaussian process classifier to this data
ind <- sample(1:dim(data)[1],30)
gpc(data,ind)
gpc(data,ind)
gpc(data,ind)
gpc(data,ind)
#### Feature selection for indices, using RATE ####
want_indices=find_rate_variables(data,radius = 2,bandwidth = 0.02);
find_rate_variables=function(gp_data,radius=0,bandwidth = 0.01){
n <- dim(gp_data)[1]
X <- gp_data[,-1]
gp_data[,1]=ifelse(gp_data[,1]>0,1,-1)
h <- bandwidth #median(dist(X)) #need a better choice of this; how does bandwidth affect kernel choice?
#RATE
f <- rep(0,n)
Kn <- GaussKernel(t(X),1/(2*h^2))
diag(Kn)=1
#Change stopping conditions for convergence
# do Newton IRLS procedure to use Laplace / Gaussian approximation.
for(k in 1:600){
W <- diag(as.vector(sigmoid(f)*(1-sigmoid(f))))
B <- diag(x = 1,n) + sqrt(W) %*% Kn %*% sqrt(W)
#Kinda show
L <- chol(B)
b <- W%*%f + (gp_data[,1]+1)/2 - sigmoid(f)
#Kinda slow
#L has components that
#Try to not use all the solves
a <- b - solve(sqrt(W)%*%t(L),solve(L,sqrt(W)%*%Kn%*%b))
f <- Kn%*%a
}
v = solve(L, sqrt(W)%*%Kn)
# generate samples from approximate posterior
#fhat samples may not be right dimensions
fhat.samples = rmvnorm(1e4,f, Kn - t(v)%*% v)
#is.positive.semi.definite(q_hat)
# use RATE:
cores = cores=detectCores()
#Dimension of Res should be 50 samples
res = RATEv2(X=X,f.draws=fhat.samples,prop.var = 1,snp.nms = colnames(X),cores = cores)
#What we want
rates=res$RATE
#print(res$RATE)
fhat.samples=0
B=0
W=0
L=0
f=0
Kn=0
want=rates>1/length(rates)
numeric_want=as.numeric(want)
want_indices=which(1==numeric_want)
real_indices=c()
for (i in 1:(length(want_indices))){
for (j in 0:radius){
real_indices=c(real_indices,want_indices[i]+j)
real_indices=c(real_indices,want_indices[i]-j)
}
}
real_indices=unique(real_indices)
return(real_indices)
}
#### Feature selection for indices, using RATE ####
want_indices=find_rate_variables(data,radius = 2,bandwidth = 0.02);
data
setwd("~/")
setwd("~/projects/SINATRA/R/Tests and Simple Examples/GaussiansOnPlaneExample")
# Visualizes the random field in an OFF file, and outputs the computed mesh.
visualize_random_field <- function(filename){
posterior_matrix1=generate_matrix_class_two(grid_length)
posterior_complex1 <- MatrixtoSimplicialComplexTriangular(posterior_matrix1,grid_length)
try_vertex1=posterior_complex1$Vertices[,1:3]
try_faces1=posterior_complex1$Faces
ind1 = rep(1,dim(try_vertex1)[1])
try_vertex1 = cbind(try_vertex1,ind1)
grf_mesh_posterior1=tmesh3d(t(try_vertex1),indices=t(try_faces1))
plot3d(grf_mesh_posterior1,col = alpha.col('grey',alpha=0.1))
aspect3d(1,1,1)
#Write to one OFF file
vcgOffWrite(grf_mesh_posterior1,filename=filename)
grf_mesh_posterior1
}
source('~/projects/SINATRA/R/Tests and Simple Examples/GaussiansOnPlaneExample/Generate_fields.R')
grf_mesh_posterior1 = visualize_random_field('GP_1')
# Visualizes the random field in an OFF file, and outputs the computed mesh.
visualize_random_field <- function(filename,type){
if(type == 1){
posterior_matrix1=generate_matrix_class_one(grid_length)
}else{
posterior_matrix1=generate_matrix_class_two(grid_length)
}
posterior_complex1 <- MatrixtoSimplicialComplexTriangular(posterior_matrix1,grid_length)
try_vertex1=posterior_complex1$Vertices[,1:3]
try_faces1=posterior_complex1$Faces
ind1 = rep(1,dim(try_vertex1)[1])
try_vertex1 = cbind(try_vertex1,ind1)
grf_mesh_posterior1=tmesh3d(t(try_vertex1),indices=t(try_faces1))
plot3d(grf_mesh_posterior1,col = alpha.col('grey',alpha=0.1))
aspect3d(1,1,1)
#Write to one OFF file
vcgOffWrite(grf_mesh_posterior1,filename=filename)
grf_mesh_posterior1
}
grf_mesh_posterior1 = visualize_random_field('GP_1',1)
grf_mesh_posterior2 = visualize_random_field('GP_2',2)
# specify the critical points for the flat plane with gaussians example.
points_1 = matrix(c(0.25,0.25,random_field_class_one(c(0.25,0.25)),
0.75,0.75,random_field_class_one(c(0.75,0.75)),
0.5,0.5,random_field_class_one(c(0.5,0.5)),
0.2,0.9,random_field_class_one(c(0.2,0.9))),nrow = 4, byrow = TRUE)
points_2 = matrix(c(0.25,0.25,random_field_class_two(c(0.25,0.25)),
0.75,0.75,random_field_class_two(c(0.75,0.75)),
0.5,0.5,random_field_class_two(c(0.5,0.5)),
0.8,0.1,random_field_class_two(c(0.8,0.1))),nrow = 4, byrow = TRUE)
#generate the desired directions
#directions = generate_equidistributed_points_hemisphere(25)
directions = matrix(c(0,0,1,
1/sqrt(3),1/sqrt(3),1/sqrt(3),
-1/sqrt(3),1/sqrt(3),1/sqrt(3),
1/sqrt(3),-1/sqrt(3),1/sqrt(3),
-1/sqrt(3),-1/sqrt(3),1/sqrt(3)),
ncol = 3, byrow = TRUE)
directions <- rbind(directions,-directions)
grid_length = 40
num_sim = 50
data = create_data_gaussian(num_sim = 50,grid_size = grid_length, dir = directions)
create_data_gaussian <- function(num_sim, grid_size=20,dir){
#Inputs:  num_sim: observations for each class
#         grid_size (int) : number of training points on [0,1]
#         length_scale (int) : parameter for RBF kernel
#         dir (kxm) array: of directions
#Ouputs: data: (2*num_sim x m array): of all the generated EC curves
# create the GP object.
# m here is the dimension of Euclidean space we are working in.
curve_length = grid_size
data <- matrix(NA,nrow=0,ncol = 1+curve_length*( dim(dir)[1]) )
for (i in 1:num_sim){
#new_data=generate_clustered_points_with_means(data_1,n=5,eta=0)
m=generate_matrix_class_one(grid_size)
complex <- MatrixtoSimplicialComplexTriangular(m,grid_length)
ec_curve <- matrix(NA,nrow = 1,ncol=0)
for (j in 1:dim(dir)[1]){
vertex_function <- cbind(complex$Vertices[,1] , complex$Vertices%*%c(dir[j,1],dir[j,2],dir[j,3]))
curve <- compute_discrete_ec_curve(complex, vertex_function, curve_length-1)
curve <- integrate_ec_curve(curve)
# omit the length data, for now
ec_curve <- c(ec_curve,curve[,2])
}
data <- rbind(data,c(1,ec_curve))
}
print('On class 2')
#Second Class
for (i in 1:num_sim){
#new_data=generate_clustered_points_with_means(data_2,n=5,eta=0)
m=generate_matrix_class_two(grid_size)
complex <- MatrixtoSimplicialComplexTriangular(m,grid_length)
ec_curve <- matrix(NA,nrow = 1,ncol=0)
for (j in 1:dim(dir)[1]){
vertex_function <- cbind(complex$Vertices[,1] , complex$Vertices%*%c(dir[j,1],dir[j,2],dir[j,3]))
curve <- compute_discrete_ec_curve(complex, vertex_function, curve_length-1)
curve <- integrate_ec_curve(curve)
# omit the length data, for now
ec_curve <- c(ec_curve,curve[,2])
}
data <- rbind(data,c(-1,ec_curve))
}
return(data)
}
data = create_data_gaussian(num_sim = 50,grid_size = grid_length, dir = directions)
data
### Feature Selection and Reconstruction ###
# We use Rate. Fit a Gaussian process classifier to this data
ind <- sample(1:dim(data)[1],30)
gpc(data,ind)
### Feature Selection and Reconstruction ###
# We use Rate. Fit a Gaussian process classifier to this data
ind <- sample(1:dim(data)[1],30)
gpc(data,ind)
create_data_gaussian <- function(num_sim, grid_size=20,dir){
#Inputs:  num_sim: observations for each class
#         grid_size (int) : number of training points on [0,1]
#         length_scale (int) : parameter for RBF kernel
#         dir (kxm) array: of directions
#Ouputs: data: (2*num_sim x m array): of all the generated EC curves
# create the GP object.
# m here is the dimension of Euclidean space we are working in.
curve_length = grid_size
data <- matrix(NA,nrow=0,ncol = 1+curve_length*( dim(dir)[1]) )
for (i in 1:num_sim){
#new_data=generate_clustered_points_with_means(data_1,n=5,eta=0)
m=generate_matrix_class_one(grid_size)
complex <- MatrixtoSimplicialComplexTriangular(m)
ec_curve <- matrix(NA,nrow = 1,ncol=0)
for (j in 1:dim(dir)[1]){
vertex_function <- cbind(complex$Vertices[,1] , complex$Vertices%*%c(0,dir[j,1],dir[j,2],dir[j,3]))
curve <- compute_discrete_ec_curve(complex, vertex_function, curve_length-1, first_column_index = TRUE)
curve <- integrate_ec_curve(curve)
# omit the length data, for now
ec_curve <- c(ec_curve,curve[,2])
}
data <- rbind(data,c(1,ec_curve))
}
print('On class 2')
#Second Class
for (i in 1:num_sim){
#new_data=generate_clustered_points_with_means(data_2,n=5,eta=0)
m=generate_matrix_class_two(grid_size)
complex <- MatrixtoSimplicialComplex(m)
ec_curve <- matrix(NA,nrow = 1,ncol=0)
for (j in 1:dim(dir)[1]){
vertex_function <- cbind(complex$Vertices[,1] , complex$Vertices%*%c(0,dir[j,1],dir[j,2],dir[j,3]))
curve <- compute_discrete_ec_curve(complex, vertex_function, curve_length-1, first_column_index = TRUE)
curve <- integrate_ec_curve(curve)
# omit the length data, for now
ec_curve <- c(ec_curve,curve[,2])
}
data <- rbind(data,c(-1,ec_curve))
}
return(data)
}
#### Feature selection for indices, using RATE ####
want_indices=find_rate_variables(data,radius = 2,bandwidth = 0.02);
#### Finding Critical Points ####
#Rate's Critical Points
selected_crit_points1_rate=as.matrix(critical_points_interval_multiple_directions(grf1,
critical_points_total1,want_indices,len,direction = directions))
