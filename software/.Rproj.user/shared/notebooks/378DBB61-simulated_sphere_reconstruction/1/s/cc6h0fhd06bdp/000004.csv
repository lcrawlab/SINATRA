"0","for (i in 1:nsim){"
"0","  sphere1 = vcgSphere(subdivision = subdivision)"
"0","  sphere2 = vcgSphere(subdivision = subdivision)"
"0","  "
"0","  # Add noise to the sphere"
"0","  sphere1$vb[1:3,] = sphere1$vb[1:3,]  * rnorm(dim(sphere1$vb)[2], mean = 1, sd = 0.02)"
"0","  sphere2$vb[1:3,] = sphere2$vb[1:3,]  * rnorm(dim(sphere2$vb)[2], mean = 1, sd = 0.02)"
"0","  "
"0","  # Elevate the causal regions - Needs to be changed"
"0","  for (j in 1:length(causal_regions_1)){"
"0","    causal_dir1 = regions[causal_regions_1[j],]"
"0","    closest_points_class1 = knnx.index(data = t(sphere$vb[-4,]),query = matrix(causal_dir1,ncol = 3), k = causal_points)"
"0","    sphere1$vb[1:3,closest_points_class1] = sphere1$vb[1:3,closest_points_class1]  * 1.55 + rnorm(1, mean = 0, sd = 0.1)"
"0","  }"
"0","  "
"0","  for (j in 1:length(causal_regions_2)){"
"0","    causal_dir2 = regions[causal_regions_2[j],]"
"0","    closest_points_class2 = knnx.index(data = t(sphere$vb[-4,]),query = matrix(causal_dir2,ncol = 3), k = causal_points)"
"0","    sphere2$vb[1:3,closest_points_class2] = sphere2$vb[1:3,closest_points_class2]  * 1.55 + rnorm(1, mean = 0, sd = 0.1)"
"0","  }"
"0","  "
"0","  # Elevate the shared regions - Needs to be changed"
"0","  for (k in 1:length(shared_regions)){"
"0","    shared_dir = regions[shared_regions[k],]"
"0","    closest_points_shared = knnx.index(data = t(sphere$vb[-4,]),query = matrix(shared_dir,ncol = 3), k = noise_points)"
"0","    shared_points = sphere$vb[1:3,closest_points_shared]  * 0.55 + rnorm(1, mean = 0, sd = 0.1)"
"0","    sphere1$vb[1:3,closest_points_shared] = shared_points"
"0","    sphere2$vb[1:3,closest_points_shared] = shared_points"
"0","    "
"0","  }"
"0","  "
"0","  "
"0","  sphere_mesh1 = convert_off_file(sphere1)"
"0","  sphere_mesh2 = convert_off_file(sphere2)"
"0","  "
"0","  ec_curve_class1 <- matrix(NA,nrow = 1,ncol=0)"
"0","  ec_curve_class2 <- matrix(NA,nrow = 1,ncol=0)"
"0","  "
"0","  ### compute EC curves for both classes of curves"
"0","  for (j in 1:dim(dir)[1]){"
"0","    "
"0","    vertex_function_class_1 <- sphere_mesh1$Vertices%*%c(dir[j,1],dir[j,2],dir[j,3])"
"0","    vertex_function_class_2 <- sphere_mesh2$Vertices%*%c(dir[j,1],dir[j,2],dir[j,3])"
"0","    "
"0","    curve1 <- compute_standardized_ec_curve(sphere_mesh1, vertex_function_class_1, curve_length-1, first_column_index = FALSE,ball_radius)"
"0","    curve2 <- compute_standardized_ec_curve(sphere_mesh2, vertex_function_class_2, curve_length-1, first_column_index = FALSE,ball_radius)"
"0","    "
"0","    # transform the ECT as desired"
"0","    curve1 <- update_ec_curve(curve1, ec_type)"
"0","    curve2 <- update_ec_curve(curve2, ec_type)"
"0","    "
"0","    # omit the length data, for now"
"0","    ec_curve_class1 <- c(ec_curve_class1,curve1[,2])"
"0","    ec_curve_class2 <- c(ec_curve_class2,curve2[,2])"
"0","  }"
"0","  "
"0","  data <- rbind(data,c(1,ec_curve_class1))"
"0","  data <- rbind(data,c(-1,ec_curve_class2))"
"0","  "
"0","}"
