% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/roc_curve_simulation.R
\name{compute_roc_curve_vertex}
\alias{compute_roc_curve_vertex}
\title{Computes the ROC curve by assessing the overlap of reconstructed vertices and causal vertices.}
\usage{
compute_roc_curve_vertex(
  data,
  class_1_causal_points,
  class_2_causal_points,
  distance_to_causal_point = 0.1,
  rate_values,
  grid_size,
  eta = 0.1,
  directions_per_cone,
  curve_length,
  directions,
  truncated = -1,
  class = 0,
  ball_radius = ball_radius,
  ball = TRUE,
  radius = 0,
  mode = "sphere",
  subdivision = 3
)
}
\arguments{
\item{data}{(list) : Metadata about the simulated shapes (vertex coordinates, etc.)}

\item{class_1_causal_points}{: Vertex indices of causal points for class 1.}

\item{class_2_causal_points}{: Vertex indices of causal points for class 2.}

\item{distance_to_causal_point}{(float) : For interpolated shapes, the distance from a vertex to the causal points to be considered a "causal vertex"}

\item{rate_values}{(vector) : Vector of variable importances for each sub-level set across each direction in a given cone.}

\item{grid_size}{(int) : The fine-ness/granularity of the interpolated shapes.}

\item{eta}{(float) : The kernel shape parameter.}

\item{directions_per_cone}{(int): The number of directions we want generated within each cone.}

\item{curve_length}{(int) : Number of sub-level sets in each EC computation.}

\item{directions}{(nx3 matrix):  The matrix of directions for which the (S/D) EC curve were computed over.}

\item{truncated}{(int) : The number of "cuts" to compute TPR/FPR for the ROC curve over. Used to speed up ROC computations.}

\item{class}{(int) : The class of the group of shapes we compute the ROC curve against.}

\item{ball_radius}{(float) : The radius of the bounding ball used if we compute the balled EC curve.}

\item{ball}{(boolean) : Denotes whether or not to compute the EC curves over a ball for uniform measurements}

\item{radius}{(int) : The number of sub-level sets "before" and "after" the selected sub-level sets we want to include (during reconstruction).}

\item{mode}{(string) : The data generation scheme. We currently support 'sphere', 'gaussian_grid", or interpolations (default).}

\item{subdivision}{(int) : The fineness of the sphere meshes (if mode == 'sphere'). We currently use subdivision = 3.}
}
\value{
total_rate_roc (matrix) : The ROC curve.
}
\description{
We compute the ROC curve by assessing the overlap of reconstructed vertices and causal vertices.
We do this for every complex in the data set then average the ROC curves.
}
